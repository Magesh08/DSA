<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Leapmile Warehouse Tracker</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <!-- <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="grid.css" /> -->

    <style>
      /* Ensure no scrolling and consistent sizing */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* General Reset and Layout Styling */
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100vh;
        width: 100vw;
        overflow: hidden; /* Prevent scrolling */
        display: flex;
        flex-direction: row;
        background-color: #faf9f9;
      }

      /* Left Section with Menu */
      .left-section {
        flex: 0 0 15%; /* Flex basis to ensure it takes 15% */
        height: 100%;
        background-color: #351c75;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        padding: 20px;
        color: #ffffff;
        font-family: Arial, sans-serif;
        border-right: 2px solid #8e7cc3;
        overflow-y: auto; /* Handle overflow for long menus */
      }

      .left-section h3 {
        margin: 0;
        padding-bottom: 10px;
        border-bottom: 2px solid #8e7cc3;
      }

      .menu-list {
        list-style-type: none;
        margin: 0;
        padding: 0;
      }

      .menu-item {
        padding: 8px;
        font-size: 16px;
        margin: 10px 0;
        cursor: pointer;
      }

      .menu-item i {
        margin-right: 10px;
        font-size: 14px;
        color: #ffffff;
      }

      .menu-item:hover {
        background-color: #8e7cc3;
        border-radius: 5px;
      }

      /* Right Section */
      .right-section {
        flex: 1; /* Automatically take up the rest of the space */
        height: 100%;
        padding: 1%;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
      }
      /* Default for large screens (monitors, large desktops) */
      .map-container {
        position: relative; /* Allow absolute positioning of child elements */
        width: 80%; /* Default width for large screens */
        /*max-width: 1400px; Limit maximum width */
        height: auto; /* Maintain aspect ratio */
        margin: 0 auto; /* Center the container */
        box-sizing: border-box; /* Include padding and border in width */
      }
      /* Large screens (desktops, 1400px and above) */
      @media (min-width: 1025px) and (max-width: 1400px) {
        .map-container {
          width: 90%; /* Adjust width for screens between 1025px and 1400px */
        }
      }

      /* Medium screens (small laptops, tablets, 1024px and below) */
      @media (max-width: 1024px) {
        .map-container {
          width: 90%; /* Adjust width for smaller laptops and tablets */
          max-width: 1200px; /* Optional: Reduce max width */
        }
      }

      /* Small screens (mobile devices, 768px and below) */
      @media (max-width: 768px) {
        .map-container {
          width: 90%; /* Take full width for small screens */
          max-width: none; /* Remove max-width constraint */
        }
      }

      .map-container img {
        width: 100%; /* Ensure the image takes full width of the container */
        height: auto; /* Maintain aspect ratio */
        display: block;
        object-fit: cover; /* Ensures the image covers the entire container */
      }
      /* Person Marker */
      .person-marker {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 12px;
        text-align: center;
        transition: transform 1s ease, opacity 1s ease; /* Smooth transition for position and opacity */
      }

      /* Default size for screens smaller than or equal to 1400px */
      .person-marker i {
        font-size: 16px; /* Smaller size for smaller screens */
        color: #000;
      }

      /* Larger size for screens greater than 1400px */
      @media (min-width: 1401px) {
        .person-marker i {
          font-size: 20px; /* Larger size for bigger screens */
          color: #000;
        }
      }

      .person-name {
        font-size: 10px;
        margin-top: 5px;
        color: #333;
      }

      /* Picking Station Marker */
      .picking-station-marker {
        position: absolute;
        display: flex;
        padding: 0px;
        margin: 0px;
        flex-direction: column;
        align-items: center;
        text-align: center;
        transition: transform 1s ease, opacity 1s ease; /* Smooth transition for position and opacity */
      }

      .picking-station-marker img {
        width: 20px;
        height: 20px;
      }

      .picking-station-marker .station-name {
        font-size: 10px;
        font-weight: 600;
        color: #000000;
      }
      .reset-button {
        margin-top: 10px;
        padding: 10px;
        background-color: #f44336;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 14px;
      }

      .reset-button:hover {
        background-color: #d32f2f;
      }
      /* Style for the highlighted menu item */
      .menu-item.selected {
        background-color: #8e7cc3; /* Light background color */
        border-radius: 5px;
        color: #ffffff; /* Blue color for text */
      }
      /* Styling for the dropdown container */
      .dropdown-container {
        margin: 20px 0px;
      }

      .dropdown-container h4 {
        font-size: 14px;
        font-weight: bold;
        color: #ffffff;
        margin-bottom: 10px;
        margin-top: 10px;
      }

      /* Styling for the hour dropdown */
      #hour-dropdown {
        width: 75%; /* Makes the dropdown take 48% of the container's width */
        padding: 10px;
        font-size: 14px;
        border: 2px solid #007bff;
        border-radius: 5px;
        background-color: #f9f9f9;
        color: #333;
        outline: none;
        transition: all 0.3s ease-in-out;
        appearance: none;
        margin-right: 4%; /* Small margin between hour and minute dropdown */
      }

      #hour-dropdown:hover {
        border-color: #0056b3;
        background-color: #eef6ff;
      }

      #hour-dropdown:focus {
        border-color: #0056b3;
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
      }

      /* Styling for the minute dropdown */
      #minute-dropdown {
        width: 75%; /* Makes the dropdown take 48% of the container's width */
        padding: 10px;
        font-size: 14px;
        margin-top: px;
        border: 2px solid #007bff;
        border-radius: 5px;
        background-color: #f9f9f9;
        color: #333;
        outline: none;
        transition: all 0.3s ease-in-out;
        appearance: none;
      }

      #minute-dropdown:hover {
        border-color: #0056b3;
        background-color: #eef6ff;
      }

      #minute-dropdown:focus {
        border-color: #0056b3;
        box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
      }

      /* Ensure both dropdowns appear in one row */
      .dropdown-container select {
        display: inline-block;
      }

      .reset-button {
        margin-top: 10px;
        padding: 10px 20px;
        font-size: 14px;
        color: white;
        background-color: #dc3545;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease-in-out;
      }

      .reset-button:hover {
        background-color: #c82333;
      }
      /* Basic button styling */
      #reset-fetch {
        margin-top: 10px;
        background-color: #007bff; /* Blue background */
        color: white; /* White text color */
        border: none; /* Remove default border */
        padding: 10px 20px; /* Add padding for size */
        font-size: 16px; /* Increase font size */
        border-radius: 5px; /* Rounded corners */
        cursor: pointer; /* Change cursor on hover */
        transition: background-color 0.3s, transform 0.2s; /* Smooth transitions */
      }

      /* Hover effect */
      #reset-fetch:hover {
        background-color: #0056b3; /* Darker blue on hover */
        transform: scale(0.9); /* Slightly enlarge on hover */
      }

      /* Focus effect (when the button is clicked) */
      #reset-fetch:focus {
        outline: none; /* Remove default outline */
        box-shadow: 0 0 2px rgba(0, 123, 255, 0.5); /* Add a focus ring */
      }

      /* Active state (when the button is pressed) */
      #reset-fetch:active {
        background-color: #004085; /* Even darker blue when pressed */
        transform: scale(1); /* Remove the hover scaling effect */
      }
      .right-section {
        position: relative;
      }

      .hexagonal-container {
        position: absolute; /* Positioning within the right-section */
        top: 27%; /* Adjust vertical positioning */
        left: 15%; /* Adjust horizontal positioning */
        transform: translate(-50%, -50%); /* Offset to center */
        width: 18%; /* 15% of the right-section width */
        height: 28%; /* 20% of the right-section height */
      }

      .hexagon {
        position: relative;
        width: 100%;
        height: 100%;
        background-color: #8e7cc3; /* Outer octagon color */
        clip-path: polygon(
          30% 0%,
          /* Top-left diagonal */ 70% 0%,
          /* Top-right diagonal */ 100% 30%,
          /* Right-top diagonal */ 100% 70%,
          /* Right-bottom diagonal */ 70% 100%,
          /* Bottom-right diagonal */ 30% 100%,
          /* Bottom-left diagonal */ 0% 70%,
          /* Left-bottom diagonal */ 0% 30% /* Left-top diagonal */
        ); /* Octagon shape */
        display: flex;
        align-items: center;
        justify-content: center;
        transform: rotate(90deg); /* Rotate the octagon by 90 degrees */
      }

      .hexagon-content {
        color: white;
        font-size: 1em;
        text-align: center;
        transform: rotate(-90deg); /* Undo the rotation for the content */
      }

      .inner-hexagon {
        position: absolute;
        width: 45%; /* Scale down for the inner octagon */
        height: 45%; /* Keep proportional */
        background-color: #ffffff; /* Inner octagon color */
        clip-path: polygon(
          30% 0%,
          70% 0%,
          100% 30%,
          100% 70%,
          70% 100%,
          30% 100%,
          0% 70%,
          0% 30%
        ); /* Inner octagon shape */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%); /* Center inside the parent octagon */
      }
      .tooltip {
        display: none;
        position: absolute;
        background-color: white;
        color: black;
        padding: 15px 20px;
        border-radius: 10px;
        font-size: 14px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        width: auto;
        max-width: 300px;
        line-height: 1.5;
        text-align: left;
      }

      .tooltip .header {
        font-weight: bold;
        font-size: 16px;
        background-color: #8e7cc3;
        color: white;
        padding: 8px;
        border-radius: 5px;
        margin-bottom: 10px;
      }

      .tooltip div {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
      }

      .tooltip .label {
        font-weight: bold;
        width: 120px; /* Fixed width for the label part */
        text-align: left;
      }

      .tooltip .value {
        text-align: right;
        flex-grow: 1;
      }

      .tooltip::before {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 5px;
        border-style: solid;
        border-color: white transparent transparent transparent;
      }

      #timelineCanvas {
        border: 1px solid #ccc;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      .marker {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        position: absolute;
      }

      /* Grid Overlay */
      /* Button Styling */
      .toggle-button {
        margin-top: 20px;
        padding: 10px 15px;
        font-size: 14px;
        border: none;
        border-radius: 5px;
        background-color: #8e7cc3;
        color: white;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .toggle-button:hover {
        background-color: #674ea7;
      }

      /* Grid Overlay */
      .grid-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%; /* Changed */
        height: 100%; /* Changed */
        display: none;
        pointer-events: none;
      }

      /* Grid Lines */
      .grid-line {
        position: absolute;
        background-color: rgba(
          0,
          0,
          0,
          0.3
        ); /* Slightly darker grid lines for better visibility */
        pointer-events: none;
        z-index: 10;
      }

      .grid-line.horizontal {
        height: 1px;
        width: 100%;
      }
      /*   
.grid-line.vertical {
  width: 1px;
  height: 100%;
} */

      /* Grid Labels */
      .grid-label {
        position: absolute;
        font-size: 10px;
        color: black;
        pointer-events: none;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <!-- Left Section -->
    <div class="left-section">
      <h3>Warehouse Menu</h3>
      <div>
        <h4>Persons</h4>
        <button id="reset-fetch">Reset</button>
        <div
          class="dropdown-container"
          id="dropdown-container"
          style="display: none"
        >
          <h4>Select Time Range</h4>

          <!-- Separate Hour Dropdown -->
          <select id="hour-dropdown">
            <option value="">Select Hour</option>
          </select>

          <!-- Separate Minute Dropdown -->
          <select id="minute-dropdown">
            <option value="">Select Minute</option>
          </select>

          <button id="reset-time" class="reset-button">Reset Time</button>
        </div>
        <ul class="menu-list" id="menu-list"></ul>
      </div>

      <button class="toggle-button" id="toggle-grid">Grid Off</button>
    </div>

    <!-- Right Section -->
    <div class="right-section">
      <canvas id="timelineCanvas"></canvas>
      <div class="map-container">
        <!-- <div class="hexagonal-container">
          <div class="hexagon">
            <div class="inner-hexagon"></div>
          </div>
        </div> -->

        <img
          src="https://storage.googleapis.com/flutterflow-io-6f20.appspot.com/projects/app-dashboard-leapmile-v2-o760fk/assets/le0xybuwgru3/AMS_Store_1.svg"
          alt="Leapmile Warehouse Tracker"
          class="map-image"
        />
        <div id="grid-overlay" style="display: none"></div>
      </div>
    </div>
    <!-- <script type="module" src="grid.js"></script> -->
    <!-- <script type="module" src="script.js"></script> -->

    <script>
      // Data for the warehouse
      // grid.js

      const gridOverlay = document.getElementById("grid-overlay");
      const toggleButton = document.getElementById("toggle-grid");
      let isGridOn = false; // Track grid visibility

      // Function to draw the grid
      const drawGrid = () => {
        gridOverlay.innerHTML = ""; // Clear previous grid
        const gridSize = 5; // Each block is 5%

        // Create vertical lines
        for (let x = 0; x <= 100; x += gridSize) {
          const line = document.createElement("div");
          line.classList.add("grid-line", "vertical");
          line.style.left = `${x}%`;
          gridOverlay.appendChild(line);
        }

        // Create horizontal lines
        for (let y = 0; y <= 100; y += gridSize) {
          const line = document.createElement("div");
          line.classList.add("grid-line", "horizontal");
          line.style.top = `${y}%`;
          gridOverlay.appendChild(line);
        }

        // Add grid labels
        for (let x = 0; x <= 100; x += gridSize) {
          for (let y = 0; y <= 100; y += gridSize) {
            const label = document.createElement("div");
            label.classList.add("grid-label");
            label.style.left = `${x}%`;
            label.style.top = `${y}%`;
            label.innerText = `(${x},${y})`;
            gridOverlay.appendChild(label);
          }
        }
      };

      // Toggle grid overlay visibility
      toggleButton.addEventListener("click", () => {
        isGridOn = !isGridOn;
        gridOverlay.style.display = isGridOn ? "block" : "none";
        if (isGridOn) drawGrid();
        toggleButton.textContent = isGridOn ? "Grid On" : "Grid Off";
      });

      // Reset the grid state to initial values
      const resetGridState = () => {
        isGridOn = false; // Reset grid visibility state
        gridOverlay.style.display = "none"; // Hide the grid if it was visible
        toggleButton.textContent = "Grid Off"; // Optionally reset button text
      };

      // Get references to required elements
      const menuList = document.getElementById("menu-list");
      const resetButton = document.getElementById("reset-fetch");
      const dropdownContainer = document.getElementById("dropdown-container");
      const hourDropdown = document.getElementById("hour-dropdown");
      const minuteDropdown = document.getElementById("minute-dropdown");
      const resetTimeButton = document.getElementById("reset-time");

      let userMarkers = {}; // Track user markers
      let stationMarkers = {}; // Track picking station markers
      let intervalId; // Store the interval ID to stop the periodic fetching
      let intervalidshuttle; // Global variable to store the interval ID
      let selectedObjectId = null; // Track the selected object ID
      let selectedHour = null; // Track the selected hour
      let selectedMinute = null; // Track the selected minute

      // Add default options for both hour and minute dropdowns
      const noneOption = document.createElement("option");
      noneOption.value = "";
      noneOption.textContent = "Select time";
      hourDropdown.appendChild(noneOption);
      minuteDropdown.appendChild(noneOption.cloneNode(true));

      // Populate hour dropdown with 1 to 24 hours
      for (let i = 1; i <= 24; i++) {
        const option = document.createElement("option");
        option.value = i;
        option.textContent = `${i} hr`;
        hourDropdown.appendChild(option);
      }

      // Populate minute dropdown with 1 to 60 minutes
      for (let i = 1; i <= 60; i++) {
        const option = document.createElement("option");
        option.value = i;
        option.textContent = `${i} min`;
        minuteDropdown.appendChild(option);
      }

      // Handle hour dropdown selection
      hourDropdown.addEventListener("change", (event) => {
        clearPersonMarkers();
        clearDottedLines();
        selectedHour = event.target.value; // Get selected hour
        console.log(`Selected Hour: ${selectedHour}`);

        // Fetch data for the selected object and time
        if (selectedObjectId) {
          fetchObjectPosition(selectedObjectId, selectedHour, selectedMinute);
        } else {
          console.log(
            "No object selected. Please select an object from the menu."
          );
        }
      });

      // Handle minute dropdown selection
      minuteDropdown.addEventListener("change", (event) => {
        clearPersonMarkers();
        clearDottedLines();
        selectedMinute = event.target.value; // Get selected minute
        console.log(`Selected Minute: ${selectedMinute}`);

        // Fetch data for the selected object and time
        if (selectedObjectId) {
          fetchObjectPosition(selectedObjectId, selectedHour, selectedMinute);
        } else {
          console.log(
            "No object selected. Please select an object from the menu."
          );
        }
      });

      // Handle reset button for time
      resetTimeButton.addEventListener("click", () => {
        hourDropdown.value = ""; // Reset hour dropdown
        minuteDropdown.value = ""; // Reset minute dropdown
        selectedHour = null; // Clear selected hour
        selectedMinute = null; // Clear selected minute
        console.log("Time reset.");

        // Fetch data for the selected object without time filter
        if (selectedObjectId) {
          fetchObjectPosition(selectedObjectId); // Fetch without time filter
        } else {
          console.log(
            "No object selected. Please select an object from the menu."
          );
        }
      });

      // Event listener to handle user click and stop periodic fetching
      menuList.addEventListener("click", (event) => {
        if (event.target && event.target.matches(".menu-item")) {
          selectedObjectId = event.target.textContent.trim(); // Get the selected object ID
          console.log("Selected Object ID:", selectedObjectId);

          // Highlight the selected item
          const menuItems = menuList.querySelectorAll(".menu-item");
          menuItems.forEach((item) => item.classList.remove("selected"));
          event.target.classList.add("selected");

          // Fetch data for the selected object
          fetchObjectPosition(selectedObjectId, selectedHour, selectedMinute); // Use selected time if available
          clearPersonMarkers(); // Clear existing markers
          clearDottedLines();
          stopPeriodicFetching(); // Stop the periodic fetching
        }
      });

      // Fetch object position based on objectId, selectedHour, and selectedMinute
      const fetchObjectPosition = (
        objectId,
        selectedHour = null,
        selectedMinute = null
      ) => {
        let url = `https://staging.qikpod.com:8977/maptracker/?object_id=${objectId}`;

        if (selectedHour) {
          url += `&hours=${selectedHour}`; // Add the hours parameter
        }

        if (selectedMinute) {
          url += `&minutes=${selectedMinute}`; // Add the minutes parameter
        }

        fetch(url, {
          method: "GET",
          headers: {
            Accept: "application/json",
            Authorization:
              "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE4NjQzNzUxODN9.3nKvoS0uuSwwZXPnv0-MyXKucUnpMBlCJuI97FR84z4",
          },
        })
          .then((response) => response.json())
          .then((data) => {
            console.log("Fetched object position:", data);
            if (data.records && data.records.length > 0) {
              updateUserListspacific(data.records); // Update user positions
            } else {
              console.log("No records found for this object_id.");
            }
          })
          .catch((error) => {
            console.error("Error fetching object position:", error);
          });
      };

      // Generic function to fetch data
      const fetchData = (objectType) => {
        return fetch(
          `https://staging.qikpod.com:8977/maptracker/user/tracker/?object_type=${objectType}`,
          {
            method: "GET",
            headers: {
              Accept: "application/json",
              Authorization:
                "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE4NjQzNzUxODN9.3nKvoS0uuSwwZXPnv0-MyXKucUnpMBlCJuI97FR84z4",
            },
          }
        ).then((response) => response.json());
      };

      // Fetch data dynamically based on object_id
      const fetchDatapickingstation = async (objectId) => {
        try {
          const response = await fetch(
            `https://staging.qikpod.com:8977/maptracker/user/tracker/?object_type=picking_station&object_id=${objectId}`,
            {
              method: "GET",
              headers: {
                Accept: "application/json",
                Authorization:
                  "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE4NjQzNzUxODN9.3nKvoS0uuSwwZXPnv0-MyXKucUnpMBlCJuI97FR84z4",
              },
            }
          );
          return response.json();
        } catch (error) {
          console.error("Error fetching data:", error);
        }
      };

      const updateUserListspacific = (users) => {
        console.log("Updating user list with positions:", users);

        const updatedIds = new Set(); // Track updated marker IDs to clean up stale markers

        // Reverse the users array to assign reversed indexes
        const reversedUsers = [...users].reverse();

        let userCoordinates = []; // Store the coordinates of the users for line drawing
        let lineColor = ""; // To hold the color for the dotted line (same as the first user)

        reversedUsers.forEach((user, index) => {
          const userId = user.id;
          updatedIds.add(userId);

          // Create a marker if it doesn't already exist
          if (!userMarkers[userId]) {
            const color = user.object_color || "black";
            const userName = index; // Assign the reversed index starting from 1
            createUserMarker(userId, userName, color);
            userMarkers[userId] = {
              markerId: `marker-${userId}`,
              color: color,
            };
          }

          const { markerId } = userMarkers[userId];
          const marker = document.getElementById(markerId);

          // Update marker position if coordinates are valid
          if (user.object_x >= 0 && user.object_y >= 0) {
            marker.style.display = "block";
            updateMarkerPosition(markerId, user);
            userCoordinates.push({
              x: user.object_x,
              y: user.object_y,
            });

            // Set the color for the dotted line as the first user's color
            if (index === 1) {
              lineColor = user.object_color || "black"; // Use the first user's color for the line
            }
          } else {
            marker.style.display = "none";
          }
        });

        // Remove markers that no longer exist in the current data
        Object.keys(userMarkers).forEach((existingId) => {
          if (!updatedIds.has(parseInt(existingId))) {
            const { markerId } = userMarkers[existingId];
            const marker = document.getElementById(markerId);
            if (marker) marker.remove();
            delete userMarkers[existingId];
          }
        });

        // Draw the line between users with the determined color
        drawDottedLine(userCoordinates, lineColor);
      };

      const drawDottedLine = (coordinates, lineColor) => {
        const mapContainer = document.querySelector(".map-container");

        // Ensure map-container is properly positioned and has dimensions
        if (!mapContainer) return;

        // Remove any previous lines before drawing new ones
        const existingLine = document.querySelector(".dotted-line");
        if (existingLine) {
          existingLine.remove();
        }

        // If there are at least two coordinates, draw a line
        if (coordinates.length > 1) {
          const svgNamespace = "http://www.w3.org/2000/svg";
          const svg = document.createElementNS(svgNamespace, "svg");
          svg.classList.add("dotted-line");
          svg.style.position = "absolute";
          svg.style.top = "0";
          svg.style.left = "0";
          svg.style.width = "100%";
          svg.style.height = "100%";

          const path = document.createElementNS(svgNamespace, "path");

          // Convert percentages to pixels based on the mapContainer size
          const containerWidth = mapContainer.offsetWidth;
          const containerHeight = mapContainer.offsetHeight;

          let pathData = `M ${(coordinates[0].x * containerWidth) / 100} ${
            (coordinates[0].y * containerHeight) / 100
          }`; // Start from the first user

          // Loop through the coordinates and create a path to connect the users
          coordinates.slice(1).forEach((coord) => {
            pathData += ` L ${(coord.x * containerWidth) / 100} ${
              (coord.y * containerHeight) / 100
            }`; // Line to each subsequent user
          });
          console.log(`line color : ${lineColor}`);

          path.setAttribute("d", pathData);
          path.setAttribute("stroke", lineColor); // Use dynamic line color
          path.setAttribute("stroke-dasharray", "5, 5"); // Dotted line
          path.setAttribute("fill", "transparent");

          svg.appendChild(path);
          mapContainer.appendChild(svg);
        }
      };
      // Function to clear the dotted lines
      const clearDottedLines = () => {
        const dottedLine = document.querySelector(".dotted-line");
        if (dottedLine) {
          dottedLine.remove(); // Remove the dotted line SVG element
        }
      };

      const updateUserListall = (users) => {
        console.log("Updating user list with positions:", users);

        users.forEach((user) => {
          const userName = user.object_id;
          const color = user.object_color || "black";

          console.log(`username: ${userName}, color: ${color}`);

          // Create and update markers if they don't exist or if they need an update
          if (!userMarkers[userName]) {
            createUserMarker(userName, userName, color);
            userMarkers[userName] = {
              markerId: `marker-${userName}`,
              color: color,
            };
          }

          const { markerId } = userMarkers[userName];
          const marker = document.getElementById(markerId);

          // Show and update marker position if coordinates are valid
          if (user.object_x >= 0 && user.object_y >= 0) {
            console.log(`markerId: ${markerId}, user:`, user);
            marker.style.display = "block";
            updateMarkerPosition(markerId, user);
          } else {
            marker.style.display = "none";
          }
        });
      };
      const updateshuttleall = (users) => {
        console.log("Updating user list with positions:", users);

        users.forEach((user) => {
          const userName = user.object_id;
          const color = user.object_color || "black";

          console.log(`username: ${userName}, color: ${color}`);

          // Create and update markers if they don't exist or if they need an update
          if (!userMarkers[userName]) {
            createShuttleMarker(userName, userName, color);
            userMarkers[userName] = {
              markerId: `marker-${userName}`,
              color: color,
            };
          }

          const { markerId } = userMarkers[userName];
          const marker = document.getElementById(markerId);

          // Show and update marker position if coordinates are valid
          if (user.object_x >= 0 && user.object_y >= 0) {
            console.log(`markerId: ${markerId}, user:`, user);
            marker.style.display = "block";
            updateMarkerPosition(markerId, user);
          } else {
            marker.style.display = "none";
          }
        });
      };

      const createUserMarker = (id, userName, color) => {
        const mapContainer = document.querySelector(".map-container");
        const marker = document.createElement("div");
        marker.className = "person-marker";
        marker.id = `marker-${id}`;
        marker.innerHTML = `<i class="fas fa-user" style="color: ${color};"></i>
                      <div class="person-name">${userName}</div>`;
        mapContainer.appendChild(marker);
      };

      const createShuttleMarker = (id, userName, color) => {
        const mapContainer = document.querySelector(".map-container");
        const marker = document.createElement("div");
        marker.className = "person-marker";
        marker.id = `marker-${id}`;
        // marker.innerHTML = `<i class="fas fa-user" style="color: ${color};"></i>
        //                     <div class="person-name">${userName}</div>`;
        marker.innerHTML = `
  <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
    <div style="width: 20px; height: 20px; background-color: black; border-radius: 20%;"></div>
    <div class="station-name" style="color: ${color}; margin-top: 5px;">${userName}</div>
  </div>
`;

        mapContainer.appendChild(marker);
      };

      const updateMarkerPosition = (markerId, user) => {
        const marker = document.getElementById(markerId);
        if (marker && user) {
          // Apply the transition effect for smooth movement
          marker.style.transition = "left 1s ease, top 1s ease"; // Smooth transition for 1 second

          // Update marker position
          marker.style.left = `${user.object_x}%`;
          marker.style.top = `${user.object_y}%`;
        }
      };
      // Function to clear person markers
      const clearPersonMarkers = () => {
        const mapContainer = document.querySelector(".map-container");
        const personMarkers = mapContainer.querySelectorAll(".person-marker");
        personMarkers.forEach((marker) => {
          marker.style.display = "none"; // Hide all person markers
        });
      };

      // Fetch all picking station data and create markers dynamically
      const initializeMarkers = async () => {
        try {
          const response = await fetch(
            "https://staging.qikpod.com:8977/maptracker/user/tracker/?object_type=picking_station",
            {
              method: "GET",
              headers: {
                Accept: "application/json",
                Authorization:
                  "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE4NjQzNzUxODN9.3nKvoS0uuSwwZXPnv0-MyXKucUnpMBlCJuI97FR84z4",
              },
            }
          );

          const data = await response.json();

          if (data && data.records) {
            data.records.forEach((record) => {
              if (!document.querySelector(`#marker-${record.object_id}`)) {
                createPickingStationMarker(
                  record.object_id,
                  record.object_color || "black",
                  record.object_id
                );
              }
            });
          } else {
            console.error("No records found.");
          }
        } catch (error) {
          console.error("Error fetching data:", error);
        }
      };

      // Create a marker dynamically and fetch additional details on hover
      const createPickingStationMarker = (stationId, color, objectId) => {
        const mapContainer = document.querySelector(".map-container");

        // Avoid duplicate markers
        if (document.querySelector(`#marker-${stationId}`)) {
          console.log(`Marker for station ID ${stationId} already exists.`);
          return;
        }

        const marker = document.createElement("div");
        marker.className = "picking-station-marker";
        marker.id = `marker-${stationId}`;
        marker.innerHTML = `
   <img
  src="https://storage.googleapis.com/flutterflow-io-6f20.appspot.com/projects/robot-dashboard-9t9j6o/assets/tt4bwe0fu2il/Pickingstation_icon.svg"
  alt="${stationId}"
  style="width: 24px; height: 24px;"
/>
    <div class="station-name" style="color: ${color};">${stationId}</div>
  `;

        // Create or find a single tooltip element
        let tooltip = document.querySelector(".tooltip");
        if (!tooltip) {
          tooltip = document.createElement("div");
          tooltip.className = "tooltip";
          tooltip.style.display = "none";
          tooltip.style.position = "absolute";
          tooltip.style.padding = "10px";
          tooltip.style.borderRadius = "5px";
          tooltip.style.fontSize = "12px";
          tooltip.style.zIndex = "1000";
          tooltip.style.maxWidth = "300px";
          mapContainer.appendChild(tooltip);
        }

        // Add marker to the container
        mapContainer.appendChild(marker);

        // Event listeners for showing/hiding the tooltip
        marker.addEventListener("mouseover", async () => {
          const data = await fetchDatapickingstation(objectId);
          if (data && data.records && data.records.length > 0) {
            const record = data.records[0];
            tooltip.innerHTML = `
      <div class="header">Station: ${record.object_id}</div>
      <div><span class="label">Type:</span><span class="value">${
        record.object_type
      }</span></div>
      <div><span class="label">Coordinates:</span><span class="value">(${
        record.object_x
      }, ${record.object_y})</span></div>
      <div><span class="label">Color:</span><span class="value">${
        record.object_color
      }</span></div>
      <div><span class="label">Created At:</span><span class="value">${new Date(
        record.created_at
      ).toLocaleString()}</span></div>
      <div><span class="label">Updated At:</span><span class="value">${new Date(
        record.updated_at
      ).toLocaleString()}</span></div>
    `;
          } else {
            tooltip.innerHTML =
              "<div>No data available for this station.</div>";
          }

          // Position the tooltip above the marker
          const markerRect = marker.getBoundingClientRect();
          const containerRect = mapContainer.getBoundingClientRect();
          tooltip.style.left = `${
            markerRect.left -
            containerRect.left +
            markerRect.width / 2 -
            tooltip.offsetWidth / 2
          }px`;
          tooltip.style.top = `${
            markerRect.top - containerRect.top - tooltip.offsetHeight - 5
          }px`;
          tooltip.style.display = "block";
        });

        marker.addEventListener("mousemove", () => {
          const markerRect = marker.getBoundingClientRect();
          const containerRect = mapContainer.getBoundingClientRect();
          tooltip.style.left = `${
            markerRect.left -
            containerRect.left +
            markerRect.width / 2 -
            tooltip.offsetWidth / 2
          }px`;
          tooltip.style.top = `${
            markerRect.top - containerRect.top - tooltip.offsetHeight - 5
          }px`;
        });

        marker.addEventListener("mouseout", () => {
          tooltip.style.display = "none";
        });

        console.log(`Created marker for station ID: ${stationId}`);
      };

      // Initialize markers when the page loads
      initializeMarkers();
      // Update picking station markers
      const updatePickingStations = (stations) => {
        stations.forEach((station) => {
          const stationId = station.object_id;

          if (!stationMarkers[stationId]) {
            const color = station.object_color || "black";
            createPickingStationMarker(stationId, color);
            stationMarkers[stationId] = {
              markerId: `marker-${stationId}`,
              color: color,
            };
          }

          const { markerId } = stationMarkers[stationId];
          const marker = document.getElementById(markerId);
          if (station.object_x >= 0 && station.object_y >= 0) {
            marker.style.display = "block";
            updateMarkerPosition(markerId, station);
          } else {
            marker.style.display = "none";
          }
        });
      };

      // Render user list in the menu
      const renderMenuList = (users) => {
        menuList.innerHTML = "";
        users.forEach((user) => {
          const listItem = document.createElement("li");
          listItem.className = "menu-item";
          listItem.innerHTML = `<i class="fas fa-user"></i> ${user.object_id}`;
          menuList.appendChild(listItem);
        });
      };

      // Handle menu item click
      menuList.addEventListener("click", (event) => {
        if (event.target && event.target.matches(".menu-item")) {
          selectedObjectId = event.target.textContent.trim(); // Extract object_id
          console.log("Selected Object ID:", selectedObjectId);

          // Highlight the selected item
          const menuItems = menuList.querySelectorAll(".menu-item");
          menuItems.forEach((item) => item.classList.remove("selected"));
          event.target.classList.add("selected");

          // Show the dropdown container
          dropdownContainer.style.display = "block";

          // Fetch data for the selected object
          fetchObjectPosition(selectedObjectId, selectedTime);
          clearPersonMarkers();

          stopPeriodicFetching();
        }
      });

      // Function to clear picking station markers
      const clearPickingStationMarkers = () => {
        const mapContainer = document.querySelector(".map-container");
        const stationMarkers = mapContainer.querySelectorAll(
          ".picking-station-marker"
        );
        stationMarkers.forEach((marker) => {
          marker.style.display = "none"; // Hide all picking station markers
        });
      };

      // Function to stop the periodic fetching
      const stopPeriodicFetching = () => {
        if (intervalId) {
          clearInterval(intervalId); // Stop the periodic fetching
          intervalId = null; // Reset the intervalId to prevent further calls
        }
      };

      // Handle reset button click
      resetButton.addEventListener("click", () => {
        resetGridState(); // Reset the grid state from grid.js
        resetFetch(); // Clear markers and reset fetch state
        dropdownContainer.style.display = "none"; // Hide the dropdown container
      });

      // Handle reset time button click
      resetTimeButton.addEventListener("click", () => {
        dropdown.value = ""; // Reset dropdown to default
        selectedTime = null; // Clear selected time
        console.log("Time reset. Selected Time:", selectedTime);
        s;
        if (selectedObjectId) {
          fetchObjectPosition(selectedObjectId); // Fetch without time filter
        } else {
          console.log(
            "No object selected. Please select an object from the menu."
          );
        }
      });

      // Function to reset fetch and clear all markers
      const resetFetch = () => {
        // Clear all markers (person markers and picking station markers)
        clearPersonMarkers();
        clearPickingStationMarkers();

        // Stop the periodic fetching
        stopPeriodicFetching();

        // Clear the menu list
        menuList.innerHTML = "";

        // Optionally, reset other states (like hiding grid or reinitializing the map state)
        const gridOverlay = document.getElementById("grid-overlay");
        gridOverlay.style.display = "none"; // Reset the grid overlay display

        // Clear the dotted lines
        clearDottedLines();

        // Fetch and update the user list and picking station data
        fetchAndUpdateUserList();
        fetchPickingStationData();

        // Restart the periodic fetching
        intervalId = setInterval(fetchAndUpdateUserList, 2000);

        console.log(
          "Fetch reset, all markers cleared, and dotted lines removed."
        );
      };

      // Fetch and update user list
      const fetchAndUpdateUserList = () => {
        fetchData("person")
          .then((data) => {
            if (data.records) {
              updateUserListall(data.records);
              renderMenuList(data.records);
            }
          })
          .catch((error) => console.error("Error fetching user list:", error));
      };
      // Function to periodically fetch shuttle updates
      const fetchAndUpdateshuttle = () => {
        fetchData("shuttle")
          .then((data) => {
            if (data.records) {
              updateshuttleall(data.records); // Update all shuttle markers
            }
          })
          .catch((error) =>
            console.error("Error fetching shuttle data:", error)
          );
      };

      // Fetch picking station data and update
      const fetchPickingStationData = () => {
        fetchData("picking_station")
          .then((data) => {
            if (data.records) {
              updatePickingStations(data.records);
            }
          })
          .catch((error) =>
            console.error("Error fetching picking station data:", error)
          );
      };

      // Function to start the periodic fetching of shuttle data
      const startPeriodicShuttleFetching = (intervalTime = 2000) => {
        if (intervalidshuttle) {
          clearInterval(intervalidshuttle); // Clear any existing interval
        }
        intervalidshuttle = setInterval(fetchAndUpdateshuttle, intervalTime); // Set a new interval
        console.log(
          `Shuttle fetching started with an interval of ${intervalTime}ms.`
        );
      };

      // Start the periodic fetching with the desired time interval
      startPeriodicShuttleFetching(2000); // Set default interval to 2000ms

      // Initialize and set intervals
      fetchAndUpdateUserList();
      intervalId = setInterval(fetchAndUpdateUserList, 2000);

      // intervalId = setInterval(fetchAndUpdateshuttle, 2000);

      fetchPickingStationData();
      setInterval(fetchPickingStationData, 20000); // Fetch picking stations every 5 seconds
    </script>
  </body>
</html>
